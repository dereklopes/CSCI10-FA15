/*
 * Project 2
 *
 * written by			Derek Lopes
 * created on			8 December 2015
 * last modified on		9 December 2015
 *
 * Create a single column spread sheet with simple
 * data calculations and different representation
 * modes of the numbers in each cell.
 *
 */
program project2;

// includes
#include( "stdlib.hhf" )
// static declarations
static
  numCells: uns8; // number of cells, starting with 1
  basePointer: dword; // pointer to the first cell in the array
  dataType: uns8; // type of data; 1 = int8, 2 = int16, 3 = int32
  representation: uns8 := 1; // representation of numbers; 1=dec, 2=bin, 3=hex
  calculation: uns8 := 1; // NEED EXPLAINATION

// procedure forward declarations

procedure editCell( basePointer_:dword; cellNumber:uns8; dataType_:uns8; representation_:uns8); @forward;

procedure showBinary8( value: byte ); @forward;

procedure showBinary16( value: word ); @forward;

procedure showBinary32( value: dword ); @forward;

procedure changeRepresentation; @forward;

procedure displayCell( label_:string; pointer_:dword; dataType_:uns8; representation_:uns8 ); @forward;

procedure displayCells( basePointer_:dword; dataType_:uns8; numCells_:uns8; representation_:uns8; calculation_:uns8 ); @forward; 

procedure createArray( dataType_:uns8; numCells_:uns8 ); @returns( "eax" ); @forward;

procedure getUns8( prompt:string; min:uns8; max:uns8 ); @returns( "al" ); @forward;

procedure getUns32( prompt:string; min:uns32; max:uns32 ); @returns( "eax" ); @forward;

procedure getInt8( prompt:string; min:Int8; max:Int8 ); @returns( "al" ); @forward;

procedure getInt16( prompt:string; min:int16; max:int16 ); @returns( "ax" ); @forward;

procedure getInt32( prompt:string; min:int32; max:int32 ); @returns( "eax" ); @forward;

// procedure definitions

procedure editCell( basePointer_:dword; cellNumber:uns8; dataType_:uns8; representation_:uns8 );
begin editCell;
  // eax holds pointer
  push( eax );
  // ebx holds new value
  push( ebx );
  // edx holds cell number
  push( edx );
    mov( 0, edx );
    dec( cellNumber );
    mov( cellNumber, dl );
    mov( basePointer_, eax );
    EDIT_DATA_1:
    cmp( dataType_, 1 );
    jne EDIT_DATA_2;
      add( edx, eax );
      displayCell( "Old value: ", eax, dataType_, representation_ );
      stdout.newln();
      push( eax );
      mov( 0, eax );
      getInt8( "Enter a new value: ", -128, 127);
      // bl holds new value
      mov( al, bl );
      pop( eax );
      mov( (type int8 bl), [eax] ); 
      jmp END_EDIT_DATA;
    EDIT_DATA_2:
    cmp( dataType_, 2 );
    jne EDIT_DATA_3;

      jmp END_EDIT_DATA;
    EDIT_DATA_3:


    END_EDIT_DATA:
  pop( ebx );
  pop( eax );
end editCell;

procedure showBinary8( value: byte );
begin showBinary8;
  push( eax );
  push( ecx );
  mov( value, al );
  stdout.put( "%" )
  for( mov( 0, cl ); cl < 8; inc( cl ) ) do
    shl( 1, al );
    if ( @c ) then
      stdout.put( "1" );
    else
      stdout.put( "0" );
    endif;
    if ( cl == 3 ) then
      stdout.put( "_" );
    endif;
  endfor;
  stdout.newln();
  pop( ecx );
  pop( eax );
end showBinary8;

procedure showBinary16( value: word );
begin showBinary16;
  push( eax );
  push( ecx );
  mov( value, ax );
  stdout.put( "%" )
  for( mov( 0, cl ); cl < 16; inc( cl ) ) do
    shl( 1, ax );
    if ( @c ) then
      stdout.put( "1" );
    else
      stdout.put( "0" );
    endif;
    if ( cl == 3 ) then
      stdout.put( "_" );
    endif;
  endfor;
  stdout.newln();
  pop( ecx );
  pop( eax );
end showBinary16;

procedure showBinary32( value: dword );
begin showBinary32;
  push( eax );
  push( ecx );
  mov( value, eax );
  stdout.put( "%" )
  for( mov( 0, cl ); cl < 8; inc( cl ) ) do
    shl( 1, eax );
    if ( @c ) then
      stdout.put( "1" );
    else
      stdout.put( "0" );
    endif;
    if ( cl == 3 ) then
      stdout.put( "_" );
    endif;
  endfor;
  stdout.newln();
  pop( ecx );
  pop( eax );
end showBinary32;

procedure changeRepresentation;
begin changeRepresentation;
  push( eax );
  stdout.put( "Choose a presentation of your data: ", nl );
  stdout.put( "[1] Decimal", nl, "[2] Binary", nl, "[3] Hexadecimal", nl );
  getUns8( "Enter your choice (1-3): ", 1, 3 );
  mov( al, representation );
  pop( eax );
end changeRepresentation;

procedure displayCell( label_:string; pointer_:dword; dataType_:uns8; representation_:uns8 );
begin displayCell;
  // eax holds pointer_
  push( eax );
  mov( pointer_, eax );
  DISPCELL_DATA_1:
  cmp( dataType_, 1 );
  jne DISPCELL_DATA_2;
    REPCELL_1_DATA_1:
    cmp( representation_, 1 );
    jne REPCELL_2_DATA_1;
      stdout.put( label_, ": ", (type int8 [eax]), nl ); 
      jmp END_DISPCELL_DATA;
    REPCELL_2_DATA_1:
    cmp( representation_, 2 );
    jne REPCELL_3_DATA_1;
      stdout.put( label_, ": " );
      showBinary8( (type int8 [eax]) );
      jmp END_DISPCELL_DATA;
    REPCELL_3_DATA_1:
      mov( [eax], edx );
      stdout.put( label_, ": $", dl, nl ); 
      jmp END_DISPCELL_DATA;  
  DISPCELL_DATA_2:
  cmp( dataType_, 2 );
  jne DISPCELL_DATA_3;
    REPCELL_1_DATA_2:
    cmp( representation_, 1 );
    jne REPCELL_2_DATA_2;
      stdout.put( label_, ": ", (type int16 [eax]), nl ); 
      jmp END_DISPCELL_DATA;
    REPCELL_2_DATA_2:
    cmp( representation_, 2 );
    jne REPCELL_3_DATA_2;
      stdout.put( label_, ": " );
      showBinary16( (type int16 [eax]) );
      jmp END_DISPCELL_DATA;
    REPCELL_3_DATA_2:
      mov( [eax], edx );
      stdout.put( label_, ": $", dx, nl ); 
      jmp END_DISPCELL_DATA;
  DISPCELL_DATA_3:
    REPCELL_1_DATA_3:
    cmp( representation_, 1 );
    jne REPCELL_2_DATA_3;
      stdout.put( label_, ": ", (type int32 [eax]), nl ); 
      jmp END_DISPCELL_DATA;
    REPCELL_2_DATA_3:
    cmp( representation_, 2 );
    jne REPCELL_3_DATA_3;
      stdout.put( label_, ": " );
      showBinary32( (type int32 [eax]) );
      jmp END_DISPCELL_DATA;
    REPCELL_3_DATA_3:
      mov( [eax], edx );
      stdout.put( label_, ": $", edx, nl ); 
      jmp END_DISPCELL_DATA;
  END_DISPCELL_DATA:
  pop( eax );
end displayCell;

procedure displayCells( basePointer_:dword; dataType_:uns8; numCells_:uns8; representation_:uns8; calculation_:uns8 );
begin displayCells;
  // eax hold array pointer
  // ebx holds current cell number
  // ecx holds array iterator
  // edx is used as an intermediary for hex output
  push( eax );
  push( ebx );
  push( ecx );
  push( edx );
  mov( basePointer_, eax );
  mov( 0, ecx );
  dec( numCells_ );
  FOR_DISPLAY:
  mov( cl, bl );
  inc( bl );
  cmp( cl, numCells_ );
  jae FOR_DISPLAY_END;
    DISP_DATA_1:
    cmp( dataType_, 1 );
    jne DISP_DATA_2;
      REP_1_DATA_1:
      cmp( representation_, 1 );
      jne REP_2_DATA_1;
        stdout.put( (type uns8 bl), ": ", (type int8 [eax + ecx]), nl ); 
        jmp END_DISP_DATA;
      REP_2_DATA_1:
      cmp( representation_, 2 );
      jne REP_3_DATA_1;
        stdout.put( (type uns8 bl), ": " );
        showBinary8( (type int8 [eax + ecx]) );
        jmp END_DISP_DATA;
      REP_3_DATA_1:
        mov( [eax + ecx], edx );
        stdout.put( (type uns8 bl), ": $", dl, nl ); 
        jmp END_DISP_DATA;  
    DISP_DATA_2:
    cmp( dataType_, 2 );
    jne DISP_DATA_3;
      REP_1_DATA_2:
      cmp( representation_, 1 );
      jne REP_2_DATA_2;
        stdout.put( (type uns8 bl), ": ", (type int16 [eax + ecx * 2]), nl ); 
        jmp END_DISP_DATA;
      REP_2_DATA_2:
      cmp( representation_, 2 );
      jne REP_3_DATA_2;
        stdout.put( (type uns8 bl), ": " );
        showBinary16( (type int16 [eax + ecx * 2]) );
        jmp END_DISP_DATA;
      REP_3_DATA_2:
        mov( [eax + ecx * 2], edx );
        stdout.put( (type uns8 bl), ": $", dx, nl ); 
        jmp END_DISP_DATA;
    DISP_DATA_3:
      REP_1_DATA_3:
      cmp( representation_, 1 );
      jne REP_2_DATA_3;
        stdout.put( (type uns8 bl), ": ", (type int32 [eax + ecx * 4]), nl ); 
        jmp END_DISP_DATA;
      REP_2_DATA_3:
      cmp( representation_, 2 );
      jne REP_3_DATA_3;
        stdout.put( (type uns8 bl), ": " );
        showBinary32( (type int32 [eax + ecx * 4]) );
        jmp END_DISP_DATA;
      REP_3_DATA_3:
        mov( [eax + ecx * 4], edx );
        stdout.put( (type uns8 bl), ": $", edx, nl ); 
        jmp END_DISP_DATA;
    END_DISP_DATA:
    inc( cl );
  jmp FOR_DISPLAY;
  FOR_DISPLAY_END:
  mov( 0, ecx );
  mov( numCells_, cl );

  CALC_CELL_DATA_1:
  cmp( dataType_, 1 );
  jne CALC_CELL_DATA_2;
    add( eax, ecx );
    jmp CALC_CELL_DATA_END;
  CALC_CELL_DATA_2:
  cmp( dataType_, 2 );
  jne CALC_CELL_DATA_3;
    push( eax );
    mov( ecx, eax );
    mul( 2, eax );
    mov( eax, ecx );
    pop( eax );
    add( eax, ecx );
    jmp CALC_CELL_DATA_END;
  CALC_CELL_DATA_3:
    push( eax );
    mov( ecx, eax );
    mul( 4, eax );
    mov( eax, ecx );
    pop( eax );
    add( eax, ecx );
  CALC_CELL_DATA_END: 

  DISP_CALC_1:
  cmp( calculation_, 1 );
  jne DISP_CALC_2;
    displayCell( "Sum: ", eax, dataType_, representation_ ); 
    jmp END_DISP_CALC;
  DISP_CALC_2:
  cmp( calculation_, 2 );
  jne DISP_CALC_3;
    displayCell( "Average: ", eax, dataType_, representation_ ); 
    jmp END_DISP_CALC;
  DISP_CALC_3:
  cmp( calculation_, 3 );
  jne DISP_CALC_4;
    displayCell( "Minimum: ", eax, dataType_, representation_ ); 
    jmp END_DISP_CALC;
  DISP_CALC_4:
    displayCell( "Maximum: ", eax, dataType_, representation_ ); 
    jmp END_DISP_CALC;
  END_DISP_CALC:
  stdout.newln();
  pop( edx );
  pop( ecx );
  pop( ebx );
  pop( eax );
end displayCells;

procedure createArray( dataType_:uns8; numCells_:uns8 );
begin createArray;
  stdout.put( nl, "Number of cells (total): ", numCells_, nl "Data type: ", dataType_, nl );
  // ebx contains number of bytes allocated
  push( ebx );
  // eax contains cell amount (1 indexed) 
  mov( 0, eax );
  mov( numCells_, al );
  CREATE_INT8:
  cmp( dataType_, 1 );
  jne CREATE_INT16;
    mov( eax, ebx );
    mem.zalloc( eax );
    jmp CREATE_END;
  CREATE_INT16:
  cmp( dataType_, 2 );
  jne CREATE_INT32;
    mul( 2, eax );
    mov( eax, ebx );
    mem.zalloc( eax );
    jmp CREATE_END;
  CREATE_INT32:
    mul( 4, eax );
    mov( eax, ebx );
    mem.zalloc( eax );
  CREATE_END:
  stdout.put( nl, (type uns32 ebx), " bytes allocated", nl );
  pop( ebx );
end createArray;

procedure getUns8( prompt:string; min:uns8; max:uns8 );
begin getUns8;
  push( ebx );
  push( ecx );
  push( esi );
  push( edi );
  FOREVER_UNS8:
    stdout.put( prompt );
    try
      stdin.getu8();
      unprotected
      IF_UNS8:
      cmp( al, min );
      jb ELSE_UNS8;
      cmp( al, max );
      ja ELSE_UNS8;
          jmp ENDFOR_UNS8;
      ELSE_UNS8:
          stdout.put( "Value must be at least ", min, " and at most ", max, ".", nl );
      END_IF_UNS8:
    anyexception
      stdout.put( "Invalid input", nl );
    endtry;
  jmp FOREVER_UNS8;
  ENDFOR_UNS8:
  pop( edi );
  pop( esi );
  pop( ecx );
  pop( ebx );
end getUns8;

procedure getUns32( prompt:string; min:uns32; max:uns32 );
begin getUns32;
  push( ebx );
  push( ecx );
  push( esi );
  push( edi );
  FOREVER_UNS32:
    stdout.put( prompt );
    try
      stdin.getu32();
      unprotected
      IF_UNS8:
      cmp( eax, min );
      jb ELSE_UNS32;
      cmp( eax, max );
      ja ELSE_UNS32;
          jmp ENDFOR_UNS32;
      ELSE_UNS32:
          stdout.put( "Value must be at least ", min, " and at most ", max, ".", nl );
      END_IF_UNS32:
    anyexception
      stdout.put( "Invalid input", nl );
    endtry;
  jmp FOREVER_UNS32;
  ENDFOR_UNS32:
  pop( edi );
  pop( esi );
  pop( ecx );
  pop( ebx );
end getUns32;

procedure getInt8( prompt:string; min:int8; max:int8 );
begin getInt8;
  push( ebx );
  push( ecx );
  push( esi );
  push( edi );
  FOREVER_INT8:
    stdout.put( prompt );
    try
      stdin.geti8();
      unprotected
      IF_INT8:
      cmp( min, al );
      jb ELSE_INT8;
        jmp ENDFOR_INT8;
      cmp( max, al );
      ja ELSE_INT8;
        jmp ENDFOR_INT8;
      ELSE_INT8:
        stdout.put( "Value must be at least ", min, " and at most ", max, ".", nl );
      END_IF_INT8:
    anyexception
      stdout.put( "Invalid input", nl );
    endtry;
  jmp FOREVER_INT8;
  ENDFOR_INT8:
  pop( edi );
  pop( esi );
  pop( ecx );
  pop( ebx );
end getInt8;

procedure getInt16( prompt:string; min:int16; max:int16 );
begin getInt16;
  push( ebx );
  push( ecx );
  push( esi );
  push( edi );
  FOREVER_INT16:
    stdout.put( prompt );
    try
      stdin.geti16();
      unprotected
      IF_INT16:
      cmp( ax, min );
      jb ELSE_INT16;
      cmp( ax, max );
      ja ELSE_INT16;
          jmp ENDFOR_INT16;
      ELSE_INT16:
          stdout.put( "Value must be at least ", min, " and at most ", max, ".", nl );
      END_IF_INT16:
    anyexception
      stdout.put( "Invalid input", nl );
    endtry;
  jmp FOREVER_INT16;
  ENDFOR_INT16:
  pop( edi );
  pop( esi );
  pop( ecx );
  pop( ebx );
end getInt16;

procedure getInt32( prompt:string; min:int32; max:int32 );;
begin getInt32;
  push( ebx );
  push( ecx );
  push( esi );
  push( edi );
  FOREVER_INT32:
    stdout.put( prompt );
    try
      stdin.geti32();
      unprotected
      IF_INT32:
      cmp( eax, min );
      jb ELSE_INT32;
      cmp( eax, max );
      ja ELSE_INT32;
          jmp ENDFOR_INT32;
      ELSE_INT32:
          stdout.put( "Value must be at least ", min, " and at most ", max, ".", nl );
      END_IF_INT32:
    anyexception
      stdout.put( "Invalid input", nl );
    endtry;
  jmp FOREVER_INT32;
  ENDFOR_INT32:
  pop( edi );
  pop( esi );
  pop( ecx );
  pop( ebx );
end getInt32;

begin project2;

  START:
  console.cls();
  getUns8( "Enter number of cells desired (2-10): ", 2, 10 ); 
  mov( al, numCells );
  inc( numCells );
  stdout.newln();
  stdout.put( "Choose a data type:", nl, "[1]int8", nl "[2]int16", nl, "[3]int32", nl );
  getUns8( "Enter your choice (1-3): ", 1, 3 );
  mov( al, dataType );

  console.cls();
  createArray( dataType, numCells );
  mov( eax, basePointer );

  // BEGIN TESTING CODE
  push( ecx );
  mov( 0, ecx );
  LOAD_DATA:
    cmp( cl, numCells );
    jae END_LOAD_DATA;
    if( dataType = 1 ) then
      mov( (type int8 cl), [eax + ecx] );
    elseif( dataType = 2 ) then
      mov( (type int16 cx), [eax + ecx * 2] );
    else
      mov( (type int32 ecx), [eax + ecx * 4] );
    endif;
    inc( ecx );
  jmp LOAD_DATA;
  END_LOAD_DATA:
  // END TESTING CODE

  stdout.put( nl, "Press ENTER to continue..." );
  stdin.flushInput();
  push( eax );
  stdin.readLn();
  pop( eax );
  console.cls();

  FOREVER_MAIN:

  displayCells( basePointer, dataType, numCells, representation, calculation ); 

  stdout.put( "[1] Edit a cell", nl, "[2] Change calculation", nl, "[3] Change presentation", nl, "[4] Reset and start over", nl, "[0] Exit program", nl, nl );
  getUns8( "Your choice (0-4): ", 0, 4 );
  MAIN_AL_0:
  cmp( al, 0 );
  jne MAIN_AL_1;
    jmp END_FOREVER_MAIN;
  MAIN_AL_1:
  cmp( al, 1 );
  jne MAIN_AL_2;
    stdout.newln();
    push( eax );
    mov( 0, eax );
    getUns8( "Enter a cell number to edit: ", 1, numCells ); 
    console.cls();
    editCell( basePointer, al, dataType, representation );
    pop( eax );
    stdout.put( nl, "Press ENTER to continue..." );
    stdin.flushInput();
    push( eax );
    stdin.readLn();
    pop( eax );
    console.cls();
    jmp MAIN_END_IF;
  MAIN_AL_2:
  cmp( al, 2 );
  jne MAIN_AL_3;
    // CHANGE CALCULATION
    console.cls();
    jmp MAIN_END_IF;
  MAIN_AL_3:
  cmp( al, 3 );
  jne MAIN_AL_4;
    changeRepresentation();
    stdout.newln();
    stdout.put( nl, "Press ENTER to continue..." );
    stdin.flushInput();
    push( eax );
    stdin.readLn();
    pop( eax );
    console.cls();
    jmp MAIN_END_IF;
  MAIN_AL_4:
    mem.free( basePointer );
    stdout.put( nl, "Memory has been cleared", nl );
    stdout.put( nl, "Press ENTER to continue..." );
    stdin.flushInput();
    push( eax );
    stdin.readLn();
    pop( eax );
    console.cls();
    jmp START;
  MAIN_END_IF:
  jmp FOREVER_MAIN;
  END_FOREVER_MAIN:
  console.cls();
  mem.free( basePointer );
  stdout.put( "Memory has been cleared", nl );
  stdout.put( nl, "Press ENTER to exit..." );
  stdin.flushInput();
  push( eax );
  stdin.readLn();
  pop( eax );
  console.cls();

end project2;
